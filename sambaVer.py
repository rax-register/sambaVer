#!/usr/bin/python3

'''

sambaVer.py version 1.2
https://github.com/rax-register/sambaVer

Description: Python-based scanner for Unix Samba Server version enumeration. smbclient versions > 4.5.8 within Kali Linux no longer display the Unix Samba version for all versions.

See: https://bugs.kali.org/view.php?id=4103 for Kali bug report.

The bug hinders users from obtaining info necessary to solve VulnHub's "Kioptrix Level 1" via exploiting the vulnerable Samba server. Although there are other ways to exploit Kioptrix Level 1 without attacking the Samba server, it is still a learning point.

Metasploit's auxiliary smb scanner (auxiliary/scanner/smb/smb_version) still detects the correct Samba version, but sambaVer.py is for those of us who don't like to rely on Metasploit.

This script uses pysmb's smbConnection to connect to a Samba server and generate the required network traffic. It then reads the packet data (response) from the Samba server and searches for the known pattern of Samba versions in the reply.

Version 1.2 changes:
  - Upgrade from python 2 to python 3.
  - Updated recv_data function to check every packet as it is received for Unix Samba version instead of compiling several packets and then checking.
  - Changed handling of '-s' option to always include "Samba #.#" when searching truncated version

Version 1.1 changes:
  - Switch from using smbclient to pysmb's smbConnection to connect to the Samba server. This change lessens the amount of network traffic generated by sambaVer.
  - Adapted exception clauses to catch errors thrown by smbConnection failures.
  - Fixed an issue where some Samba server versions were reported with a trailing '-' character.
  
Additional Notes: 

  - A future version may remove the '-2x' and '-D' options as they may be useless now that sambaVer does not use smbclient

  - A manual way to find the Samba version is to run tcpdump or Wireshark and visually inspect the responses from the Samba server.

  - Offered under the terms of the MIT License. See LICENSE file for details.

author: register
email:  bytesandorbits@gmail

'''

import argparse, os, re, signal, socket, string, subprocess, sys, time
from smb.SMBConnection import SMBConnection
from smb import smb_structs

############################# global variables #############################


# current version
current_Ver = "1.2"

# initialize variable containing a list of printable characters
print_Char = set(string.printable)

# initialize variable to double the number of attempts. set by command line argument only
double_Trouble = False

# initialize variable to modify the timeout setting. set by command line argument only
timer_Multiplier = 1

# initialize variable to automatically search for exploits using searchsploit. set by command line argument only
get_Exploit = False

# turn off SMB2 for pysmb connections
smb_structs.SUPPORT_SMB2 = False


########################### end global variables ###########################


############################## function block ##############################


# function to receive and search through socket data for Samba server versions:
def recv_data(_sock, _multi):

    # set timeout based on the multiplier and make the socket non-blocking
    timeout = 1 * _multi
    _sock.setblocking(0)
    
    # local variables to store data
    all_Data = ''
    part_Data = ''
    
    # starting time
    start_Time = time.time()

    # loop to receive data in chunks and append it to a single variable
    while 1:
        # if data is received, then break after timeout has been reached
        if all_Data and time.time() - start_Time > timeout:
            break
        
        # if data is not received, wait twice the timeout
        elif time.time() - start_Time > timeout * 2:
            break
        
        # receive data, decode it, and then parse it for legible characters
        try:
            part_Data = _sock.recvfrom(4096)
            part_Data = part_Data[0].decode('ISO-8859-1').strip()

            legible_Data = ''
            _i = 0
        
            while _i < len(part_Data):
                legible_Data+=str(list([x for x in part_Data[_i][0] if x in print_Char])).strip('[]\'')
                _i += 1

            # search the legible data for a Samba server version and store the result in search_Samba
            search_Samba = re.search(r'(Samba [\d].[\d].[\d]+[a-d]?)', legible_Data, re.I)

            # if we have a Samba version, exit this function and return the version info
            if search_Samba:
                return search_Samba

            else:
                time.sleep(0.1)

        except Exception as msg:
            pass


# function to exit cleanly:
def clean_exit(_s):

    _s.close()
    sys.exit(0)


# function to deliver the bad news:
def no_soup_for_you(_come_back_one_year):
    print("=============================================")
    print("[-]  Error connecting to the smb server") 
    print("[-]  You may be scanning a Windows device or a system that does not have port 139 open")
    print("[-]  Check to ensure the host is a Unix/Linux machine with port 139 open before trying again")          
    print("=============================================\n")
    clean_exit(_come_back_one_year)


# function to deliver the good news:
def great_success(_great, _success):

    global get_Exploit

    print("**********************************************")
    print("[+]  Found Unix Samba Version: ", _success)
    print("**********************************************\n")

    # did the user set the '-s' flag? if so we run searchsploit
    if get_Exploit:
        _success = _success[0:9]
        print("Executing searchsploit", _success, ":")
        os.system("searchsploit " + _success)
 
    clean_exit(_great)


# function to handle arguments on the command line:
def parser_stuff():

    global double_Trouble
    global timer_Multiplier
    global get_Exploit

    # define various command line options for use
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", help="Samba Server IP Address (Mandatory)")
    parser.add_argument("-2x", "--double", help="Doubles the attempts to increase success rate on slower connections", action="store_true")
    parser.add_argument("-D", "--Deliberate", help="Doubles the attempts and increases the timer. This will be a slow scan with the highest chance of success.", action="store_true")
    parser.add_argument("-s", "--searchsploit", help="Run searchsploit against truncated version information detected", action="store_true")

    # process command line arguments               
    args = parser.parse_args()

    # remind user to include the mandatory argument if they forgot
    if not args.target:
        print("Please Specify Samba Server with -t or --target option")                        
        sys.exit(1)                 

    # set global variable
    if args.double:
        double_Trouble = True
        print("Doubling the usual number of attempts. If this doesn't work, try -D")

    if args.Deliberate:
        double_Trouble = True
        timer_Multiplier = 4
        print("Doubling the number of attempts and extending the timer on the socket listener. This may take a moment...")

    if args.searchsploit:
        get_Exploit = True
        print("Will run a truncated Samba version against searchsploit")
       
    return args.target


# main function:
def main():

    global timer_Multiplier
    
    # print version info and take care of parsing arguments
    print("sambaVer.py version: ", current_Ver)
    _server = parser_stuff()

    # once arguments are checked, print message
    print("\nExecuting scan against:", _server)

    # initialize variables to track the loops without indications of Unix Samba
    non_Samba = 0
    max_Allowed = 2

    # if user set the '-2x' flag, double the number of attempts    
    if double_Trouble:
        max_Allowed = max_Allowed * 2

    # initialize variables for SMBConnection
    conn = ''
    userID = ''
    password = ''
    client_machine_name = ''
    server_name = ''
    domain_name = ''

    # start of primary while loop:
    while True:

        try:
            # create the socket variable to store received data to parse for Unix Samba versions
            s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))

            # establish SMB connection using blank credentials (anonymous)
            conn = SMBConnection(userID, password, client_machine_name, server_name)
            conn.connect(_server, 139)
        
            # call the function to receive and process data
            print_Data = recv_data(s, timer_Multiplier)
            s.close()
            conn.close

            # if we have a Samba version, call a function to deliver the good news
            if print_Data:
                samba_Ver = print_Data.group(1)
                great_success(s, samba_Ver)

            # increment counter if data does not indicate a Unix Samba server
            if "Unix" not in print_Data and "Samba" not in print_Data:
                non_Samba += 1

            # if the primary while loop has executed multiple times with no result, 
            # call the function to deliver the bad news
            if non_Samba > max_Allowed:
                no_soup_for_you(s)

        # display an error and exit cleanly if a socket connection cannot be established
        except socket.error as msg:
            print("Unable to create socket:", msg)
            clean_exit(s)

        # handle smb connection errors
        except Exception:
            no_soup_for_you(s)

        # handle user initiated Ctrl+c interrupts
        except KeyboardInterrupt:
            print("Interrupt received. Cleaning up, then ending program.")
            clean_exit(s)

############################ end function block ############################


# Engage!
main()
